# Vue.js & JavaScript チートシート - VSCode開発者向け（詳細解説版）

## Vue.js 基本構文 - 一行ずつ解説

### コンポーネント定義（Options API）
```vue
<template>
  <!-- テンプレートセクション：HTMLを記述する -->
  <div>
    <!-- {{ }} は変数の値を表示する構文（マスタッシュ記法） -->
    <h1>{{ title }}</h1>
    <!-- @click はv-on:clickの省略記法、クリックイベントハンドラーを設定 -->
    <button @click="handleClick">クリック</button>
  </div>
</template>

<script>
// ESモジュールの標準的なエクスポート構文
export default {
  // コンポーネント名を指定（デバッグ時に便利）
  name: 'ComponentName',
  // リアクティブなデータを定義する関数
  data() {
    // 新しいインスタンスごとに新しいデータオブジェクトを返す
    return {
      // title変数に初期値を設定
      title: 'Hello Vue'
    }
  },
  // イベントハンドラーやカスタムメソッドを定義
  methods: {
    // this経由でdataにアクセス可能
    handleClick() {
      // コンソールにログを出力
      console.log('clicked')
    }
  }
}
</script>

<style scoped>
/* scopedを指定すると、このコンポーネント内のみに適用される */
/* グローバルスタイルに影響を与えない */
</style>
```

### コンポーネント定義（Composition API）
```vue
<template>
  <div>
    <!-- Composition APIでも同じテンプレート構文 -->
    <h1>{{ title }}</h1>
    <button @click="handleClick">クリック</button>
  </div>
</template>

<script setup>
// refをインポート（リアクティブな値を作成） 
import { ref } from 'vue'

// ref()でリアクティブな変数を作成（.valueでアクセス）
const title = ref('Hello Vue')

// 通常の関数として定義（setupコンテキスト内で自動的に公開）
const handleClick = () => {
  console.log('clicked')
}
</script>
```

### データバインディング
```vue
<template>
  <!-- テキスト補間：変数の値をそのまま表示 -->
  <p>{{ message }}</p>
  
  <!-- v-bind:srcの省略記法（:src） -->
  <!-- 属性に変数値をバインド -->
  <img :src="imageUrl" :alt="altText">
  
  <!-- クラスバインディング：条件に応じてクラスを適用 -->
  <!-- isActiveがtrueの時'active'クラスを適用 -->
  <div :class="{ active: isActive, 'text-danger': hasError }"></div>
  
  <!-- インラインスタイルバインディング -->
  <!-- JavaScriptオブジェクトでスタイルを指定 -->
  <div :style="{ color: textColor, fontSize: fontSize + 'px' }"></div>
  
  <!-- v-model：双方向データバインディング -->
  <!-- input値の変更が自動的に変数に反映される -->
  <input v-model="message">
</template>
```

### 条件付きレンダリング
```vue
<template>
  <!-- v-if：条件が真の時のみ要素を描画（DOM操作あり） -->
  <div v-if="isVisible">表示</div>
  
  <!-- v-else-if：前のv-ifが偽の時に次の条件をチェック -->
  <div v-else-if="isLoading">読み込み中</div>
  
  <!-- v-else：すべての条件が偽の時に表示 -->
  <div v-else>非表示</div>
  
  <!-- v-show：DOMには残るが、display:noneで表示/非表示 -->
  <!-- 切り替えが頻繁な場合はv-showが有利 -->
  <div v-show="showContent">コンテンツ</div>
</template>
```

### リストレンダリング
```vue
<template>
  <ul>
    <!-- v-for：配列の各要素に対してリピート -->
    <!-- :key は一意の識別子（パフォーマンス最適化に必要） -->
    <li v-for="item in items" :key="item.id">
      {{ item.name }}
    </li>
  </ul>
  
  <!-- インデックスも取得する場合 -->
  <!-- (item, index)の順序で取得 -->
  <div v-for="(item, index) in items" :key="index">
    {{ index }}: {{ item }}
  </div>
</template>
```

### イベントハンドリング
```vue
<template>
  <!-- v-on:clickの省略記法（@click） -->
  <button @click="onClick">クリック</button>
  
  <!-- メソッドに引数を渡す -->
  <button @click="onSubmit('data')">送信</button>
  
  <!-- イベント修飾子：preventDefault()を自動実行 -->
  <form @submit.prevent="onSubmit"></form>
  
  <!-- イベントのバブリングを停止 -->
  <div @click.stop="onClick"></div>
  
  <!-- 特定のキーに反応（Enterキー） -->
  <input @keyup.enter="onEnter">
  
  <!-- 1回のみ実行されるイベント -->
  <button @click.once="onOnceClick">1回だけ</button>
</template>
```

### コンポーネント間通信
```vue
<!-- 親コンポーネント -->
<template>
  <!-- 子コンポーネントにpropsとして値を渡す -->
  <!-- @child-eventで子からのカスタムイベントを受信 -->
  <ChildComponent 
    :message="parentMessage"
    @child-event="handleChildEvent"
  />
</template>

<script setup>
// 子コンポーネントをインポート
import ChildComponent from './ChildComponent.vue'

// 子からのイベントをハンドリングする関数
const handleChildEvent = (data) => {
  console.log(data)
}
</script>

<!-- 子コンポーネント -->
<script setup>
// props定義：親からのデータを受け取る
const props = defineProps({
  message: String  // messageはString型
})

// emit定義：親に送信できるイベントを宣言
const emit = defineEmits(['child-event'])

// 親にデータを送信する関数
const sendData = () => {
  // 第1引数：イベント名、第2引数：送信データ
  emit('child-event', 'データ')
}
</script>
```

## JavaScript 基本構文 - 一行ずつ解説

### 変数宣言
```javascript
// const：再代入不可の定数宣言（ES6+）
const name = '田中'
// オブジェクトや配列自体は変更可能
const numbers = [1, 2, 3]

// let：再代入可能な変数宣言（ES6+）
let count = 0
// 新しい値を代入
count = 1

// var：関数スコープの変数（古い方式、避けるべき）
var oldStyle = 'avoid'
```

### 関数
```javascript
// 関数宣言：巻き上げが発生する
function greet(name) {
  // テンプレートリテラルで文字列結合
  return `Hello ${name}`
}

// 関数式：変数に関数を代入
const greet = function(name) {
  return `Hello ${name}`
}

// アロー関数：より簡潔な構文（ES6+）
const greet = (name) => {
  return `Hello ${name}`
}

// 単一式の場合はreturnを省略可能
const greet = name => `Hello ${name}`

// デフォルト引数：引数が渡されない場合の初期値
const greet = (name = 'Guest') => `Hello ${name}`
```

### オブジェクト
```javascript
// オブジェクトリテラル記法
const user = {
  // プロパティの定義
  name: '田中',
  age: 30,
  // メソッドの簡潔な記法（ES6+）
  greet() {
    // thisはそのオブジェクト自身を参照
    return `Hello ${this.name}`
  }
}

// 分割代入：オブジェクトから複数の値を取り出す
const { name, age } = user

// スプレッド演算子：既存オブジェクトに新しいプロパティを追加
const newUser = { ...user, email: 'tanaka@example.com' }

// 動的プロパティ：変数値をプロパティ名として使用
const key = 'name'
const obj = {
  [key]: '値'  // このオブジェクトは{name: '値'}になる
}
```

### 配列
```javascript
// 配列リテラル記法
const numbers = [1, 2, 3, 4, 5]

// map：各要素を変換した新しい配列を生成
const doubled = numbers.map(n => n * 2)  // [2, 4, 6, 8, 10]

// filter：条件に合致する要素だけを抽出
const evens = numbers.filter(n => n % 2 === 0)  // [2, 4]

// reduce：配列を単一の値に集約
// accは累積値、nは現在の要素、0は初期値
const sum = numbers.reduce((acc, n) => acc + n, 0)  // 15

// find：条件に合う最初の要素を取得
const found = numbers.find(n => n > 3)  // 4

// forEach：各要素に対して処理を実行（副作用用）
numbers.forEach(n => console.log(n))

// 分割代入：最初の要素、2番目の要素、残り要素
const [first, second, ...rest] = numbers

// スプレッド演算子：配列の結合
const combined = [...numbers, 6, 7, 8]
```

### 非同期処理
```javascript
// Promise：非同期処理の結果を扱う
const fetchData = () => {
  // Promiseコンストラクタは実行関数を受け取る
  return new Promise((resolve, reject) => {
    // 非同期処理のシミュレーション
    setTimeout(() => {
      // 成功時はresolveを呼ぶ
      resolve('データ')
    }, 1000)
  })
}

// async/await：非同期処理の同期的記述
const getData = async () => {
  try {
    // awaitでPromiseの解決を待つ
    const data = await fetchData()
    console.log(data)
  } catch (error) {
    // エラーが発生した場合の処理
    console.error(error)
  }
}

// fetch API：HTTP通信を行う
const fetchUser = async () => {
  // fetch関数は自動的にPromiseを返す
  const response = await fetch('/api/user')
  // レスポンスのJSONを解析
  const data = await response.json()
  return data
}
```

### クラス
```javascript
// ES6のクラス構文
class Person {
  // コンストラクタ：インスタンス作成時に実行
  constructor(name, age) {
    // インスタンスプロパティの設定
    this.name = name
    this.age = age
  }
  
  // インスタンスメソッド
  greet() {
    return `Hello, I'm ${this.name}`
  }
  
  // 静的メソッド：クラス自体に紐付く
  static compare(person1, person2) {
    return person1.age - person2.age
  }
}

// 継承：extendsで親クラスから拡張
class Student extends Person {
  constructor(name, age, school) {
    // super()で親のコンストラクタを呼び出す
    super(name, age)
    // 子クラス独自のプロパティ
    this.school = school
  }
  
  // 新しいメソッドの追加
  study() {
    return `${this.name} is studying at ${this.school}`
  }
}
```

### モジュール
```javascript
// エクスポート：値や関数をモジュール外に公開
// 名前付きエクスポート
export const name = '田中'
export function greet() {
  return 'Hello'
}

// デフォルトエクスポート：1つのモジュールに1つまで
export default class User {
  // クラス定義
}

// インポート：他のモジュールから読み込み
// デフォルトエクスポートと名前付きエクスポート
import User, { name, greet } from './user'
// ワイルドカードインポート
import * as userModule from './user'
// エイリアス付きインポート
import { name as userName } from './user'
```

## 実用例 - 一行ずつ解説

### ユーザーリストコンポーネント
```vue
<template>
  <!-- ユーザーリスト全体のコンテナ -->
  <div class="user-list">
    <!-- 検索用入力フィールド、双方向バインディング -->
    <input v-model="searchQuery" placeholder="検索...">
    
    <!-- 読み込み中の表示（v-ifで条件分岐） -->
    <div v-if="loading">読み込み中...</div>
    <!-- エラー時の表示 -->
    <div v-else-if="error">エラー: {{ error }}</div>
    <!-- 通常時のユーザーリスト表示 -->
    <div v-else>
      <!-- フィルタリングされたユーザーをループ表示 -->
      <div v-for="user in filteredUsers" :key="user.id" class="user-item">
        <!-- ユーザーのアバター画像 -->
        <img :src="user.avatar" :alt="user.name">
        <!-- ユーザー情報のコンテナ -->
        <div>
          <!-- ユーザー名 -->
          <h3>{{ user.name }}</h3>
          <!-- メールアドレス -->
          <p>{{ user.email }}</p>
        </div>
        <!-- 削除ボタン、クリックでdeleteUser実行 -->
        <button @click="deleteUser(user.id)">削除</button>
      </div>
    </div>
  </div>
</template>

<script setup>
// Vue.jsのリアクティブAPIをインポート
import { ref, computed, onMounted } from 'vue'

// ユーザーデータを格納する配列（初期値は空配列）
const users = ref([])
// 検索クエリ文字列（初期値は空文字）
const searchQuery = ref('')
// 読み込み状態フラグ（初期値はfalse）
const loading = ref(false)
// エラーメッセージ（初期値はnull）
const error = ref(null)

// 算出プロパティ：検索結果のフィルタリング
const filteredUsers = computed(() => {
  // 検索クエリが空なら全ユーザーを返す
  if (!searchQuery.value) return users.value
  // 検索クエリに部分一致するユーザーのみを返す
  return users.value.filter(user => 
    user.name.toLowerCase().includes(searchQuery.value.toLowerCase())
  )
})

// ユーザーデータ取得の非同期関数
const fetchUsers = async () => {
  // 読み込み開始時の状態設定
  loading.value = true
  error.value = null
  try {
    // APIからデータ取得
    const response = await fetch('/api/users')
    // レスポンスをJSONに変換してusersに格納
    users.value = await response.json()
  } catch (err) {
    // エラー発生時はエラーメッセージを設定
    error.value = err.message
  } finally {
    // 処理完了時（成功・失敗問わず）読み込み終了
    loading.value = false
  }
}

// ユーザー削除の非同期関数
const deleteUser = async (id) => {
  try {
    // DELETEリクエストでユーザー削除
    await fetch(`/api/users/${id}`, { method: 'DELETE' })
    // ローカルのユーザーリストからも削除
    users.value = users.value.filter(user => user.id !== id)
  } catch (err) {
    // エラー発生時はコンソールに出力
    console.error('削除エラー:', err)
  }
}

// コンポーネントマウント時にユーザーデータを取得
onMounted(fetchUsers)
</script>

<style scoped>
/* ユーザーリスト全体のスタイル */
.user-list {
  max-width: 600px;
  margin: 0 auto;
}

/* 各ユーザーアイテムのスタイル */
.user-item {
  display: flex;        /* フレックスレイアウト */
  align-items: center;  /* 垂直中央揃え */
  gap: 1rem;           /* 子要素間のスペース */
  padding: 1rem;
  border: 1px solid #ddd;
  margin-bottom: 0.5rem;
}

/* ユーザーアバター画像のスタイル */
.user-item img {
  width: 50px;
  height: 50px;
  border-radius: 50%;   /* 円形に切り抜き */
}
</style>
```

### 状態管理（Pinia）
```javascript
// stores/user.js
// PiniaのdefineStoreをインポート
import { defineStore } from 'pinia'

// ユーザー用のストアを定義
export const useUserStore = defineStore('user', {
  // 状態の初期化（Vuexのstateに相当）
  state: () => ({
    // 現在のユーザー情報（初期値はnull）
    user: null,
    // 認証状態フラグ（初期値はfalse）
    isAuthenticated: false
  }),
  
  // ゲッター：状態から派生する値（Vuexのgettersに相当）
  getters: {
    // ユーザー名の取得（未ログイン時はGuest）
    username: (state) => state.user?.name || 'Guest',
    // 管理者権限チェック
    isAdmin: (state) => state.user?.role === 'admin'
  },
  
  // アクション：状態を変更する非同期/同期処理（Vuexのmutations+actionsに相当）
  actions: {
    // ログイン処理の非同期関数
    async login(credentials) {
      try {
        // APIにログイン情報を送信
        const response = await fetch('/api/login', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(credentials)
        })
        
        // レスポンスが成功の場合
        if (response.ok) {
          // ユーザー情報を取得して状態に保存
          this.user = await response.json()
          // 認証フラグをtrueに設定
          this.isAuthenticated = true
          // 成功フラグを返す
          return true
        }
        // 失敗時はfalseを返す
        return false
      } catch (error) {
        // エラー発生時はコンソールに出力
        console.error('ログインエラー:', error)
        return false
      }
    },
    
    // ログアウト処理
    logout() {
      // ユーザー情報をリセット
      this.user = null
      // 認証フラグをfalseに設定
      this.isAuthenticated = false
    }
  }
})

// 使用例
<script setup>
// ユーザーストアを読み込み
import { useUserStore } from '@/stores/user'

// ストアのインスタンスを取得
const userStore = useUserStore()

// ログイン処理を行う関数
const handleLogin = async () => {
  // ストアのloginアクションを実行
  const success = await userStore.login({
    email: 'user@example.com',
    password: 'password'
  })
  
  // ログイン成功時はダッシュボードに遷移
  if (success) {
    router.push('/dashboard')
  }
}
</script>
```

## デバッグとパフォーマンス最適化

### Vue Devtoolsでのデバッグ
```javascript
// コンポーネントからデータを確認する方法
console.log(this.$data) // Options API
console.log({ ...reactive_data }) // Composition API

// イベントオブジェクトをキャッチしてデバッグ
<button @click="e => console.log(e)">クリック</button>
```

### エラーハンドリング
```javascript
// アプリケーション全体のエラーハンドラー設定
const app = createApp(App)
app.config.errorHandler = (err, instance, info) => {
  // エラーオブジェクトをログ出力
  console.error('Vue Error:', err)
  // エラーが発生したコンポーネントインスタンス
  console.log('Component:', instance)
  // Vueが提供する追加情報
  console.log('Info:', info)
}

// コンポーネント内でエラーをキャッチ
export default {
  // 子コンポーネントのエラーを捕捉
  errorCaptured(err, instance, info) {
    console.error('Error captured:', err)
    // falseを返すとエラーの伝播を停止
    return false
  }
}
```

### パフォーマンス最適化技術
```javascript
// コンポーネントの遅延ローディング
const LazyComponent = defineAsyncComponent(() => import('./LazyComponent.vue'))

// v-memo：依存値が変化しない限り再レンダリングをスキップ
<template>
  <div v-memo="[valueA, valueB]">
    <!-- 高コストな計算や描画処理 -->
  </div>
</template>

// KeepAlive：コンポーネントの状態を保持
<template>
  <keep-alive>
    <!-- 切り替え時にコンポーネントを破棄せず状態を保持 -->
    <component :is="currentComponent" />
  </keep-alive>
</template>
```
## Vue Router - ルーティング管理

### 基本的なルーター設定
```javascript
// router/index.js
// VueRouterをインポート
import { createRouter, createWebHistory } from 'vue-router'
// コンポーネントをインポート
import Home from '../views/Home.vue'

// ルート定義配列
const routes = [
  {
    // URLパス
    path: '/',
    // ルート名（オプション）
    name: 'Home',
    // このルートで使用するコンポーネント
    component: Home
  },
  {
    path: '/about',
    name: 'About',
    // 動的インポート（コード分割）
    component: () => import(/* webpackChunkName: "about" */ '../views/About.vue')
  },
  {
    // 動的ルート（:idが変数部分）
    path: '/user/:id',
    name: 'User',
    component: () => import('../views/User.vue'),
    // ルートにPropsを渡す
    props: true
  },
  {
    // ネストされたルート
    path: '/dashboard',
    component: () => import('../views/Dashboard.vue'),
    children: [
      {
        // 相対パス（親の/dashboardに続く）
        path: 'profile',
        component: () => import('../views/Profile.vue')
      }
    ]
  }
]

// ルーターインスタンスを作成
const router = createRouter({
  // HTML5 History APIを使用
  history: createWebHistory(process.env.BASE_URL),
  // 定義したルートを適用
  routes
})

// beforeEachガード：すべてのナビゲーション前に実行
router.beforeEach((to, from, next) => {
  // 認証が必要なルートのチェック
  if (to.meta.requiresAuth && !isAuthenticated()) {
    // 未認証ならログインページへリダイレクト
    next('/login')
  } else {
    // 認証済みまたは認証不要なら続行
    next()
  }
})

// ルーターをエクスポート
export default router
```

### ルーターの使用方法
```vue
<template>
  <!-- ナビゲーション用のリンク -->
  <!-- router-linkは自動的に現在のルートにactiveクラスを付与 -->
  <nav>
    <router-link to="/">ホーム</router-link>
    <router-link to="/about">概要</router-link>
    <!-- named routeの使用 -->
    <router-link :to="{ name: 'User', params: { id: userId } }">
      ユーザー
    </router-link>
  </nav>
  
  <!-- ルートコンポーネントが表示される場所 -->
  <router-view></router-view>
</template>

<script setup>
// ルーターのコンポーザブル関数
import { useRouter, useRoute } from 'vue-router'

// ルーターインスタンスを取得（ナビゲーション用）
const router = useRouter()
// 現在のルート情報を取得
const route = useRoute()

// プログラマティックナビゲーション
const goToUser = (id) => {
  // 文字列パス
  router.push(`/user/${id}`)
  
  // オブジェクト形式
  router.push({ name: 'User', params: { id } })
  
  // クエリパラメータの追加
  router.push({ 
    path: '/search', 
    query: { q: 'vue' } 
  }) // /search?q=vue
}

// ブラウザ履歴を操作せずに置き換える
const replaceRoute = () => {
  router.replace('/dashboard')
}

// 履歴を戻る
const goBack = () => {
  router.go(-1)
}

// ルートパラメータの監視
watchEffect(() => {
  console.log('現在のユーザーID:', route.params.id)
})
</script>
```

## カスタムディレクティブ - 一行ずつ解説

### カスタムディレクティブの作成
```javascript
// グローバルディレクティブの定義
const app = createApp({})
app.directive('focus', {
  // el: ディレクティブが適用される要素
  // binding: v-directiveの値、引数、修飾子などの情報
  // vnode: Vue仮想ノード
  mounted(el, binding, vnode) {
    // 要素にフォーカスを当てる
    el.focus()
  }
})

// より複雑なディレクティブ例
app.directive('highlight', {
  // コンポーネントマウント時
  mounted(el, binding) {
    // binding.valueにはv-highlight="'yellow'"の'yellow'が入る
    el.style.backgroundColor = binding.value || 'yellow'
  },
  // 値が更新された時
  updated(el, binding) {
    // 新しい値で背景色を更新
    el.style.backgroundColor = binding.value || 'yellow'
  }
})

// 引数付きディレクティブ
app.directive('color', {
  mounted(el, binding) {
    // binding.argにはv-color:textのtextが入る
    const property = binding.arg || 'color'
    // 指定されたCSSプロパティを設定
    el.style[property] = binding.value
  }
})

// 修飾子付きディレクティブ
app.directive('scroll', {
  mounted(el, binding) {
    // binding.modifiersはオブジェクト形式
    if (binding.modifiers.smooth) {
      // v-scroll.smoothの場合
      el.style.scrollBehavior = 'smooth'
    }
  }
})
```

### ローカルディレクティブの使用
```vue
<template>
  <!-- カスタムディレクティブの使用例 -->
  <input v-focus>
  <div v-highlight="'lightblue'">ハイライト</div>
  <span v-color:text="'red'">赤文字</span>
  <div v-scroll.smooth>スムーズスクロール</div>
</template>

<script setup>
// コンポーネント内でディレクティブを定義
const vFocus = {
  mounted(el) {
    el.focus()
  }
}

// 複雑なディレクティブ
const vClickOutside = {
  mounted(el, binding) {
    // クリックイベントハンドラーを定義
    el.clickOutsideEvent = function(event) {
      // クリックが要素外の場合
      if (!(el === event.target || el.contains(event.target))) {
        // binding.valueの関数を実行
        binding.value(event)
      }
    }
    // documentにイベントリスナーを追加
    document.addEventListener('click', el.clickOutsideEvent)
  },
  unmounted(el) {
    // クリーンアップ：イベントリスナーを削除
    document.removeEventListener('click', el.clickOutsideEvent)
  }
}
</script>
```

## 高度なコンポーネントパターン

### プロバイド/インジェクト
```vue
<!-- 親コンポーネント -->
<script setup>
import { provide, ref } from 'vue'

// リアクティブな値を提供
const theme = ref('light')
const user = ref({ name: '田中', role: 'admin' })

// provide(key, value)で値を提供
provide('theme', theme)
provide('user', user)

// 関数も提供可能
provide('toggleTheme', () => {
  theme.value = theme.value === 'light' ? 'dark' : 'light'
})
</script>

<!-- 深くネストされた子コンポーネント -->
<script setup>
import { inject } from 'vue'

// inject(key, defaultValue)で値を注入
const theme = inject('theme', 'light')
const user = inject('user')
const toggleTheme = inject('toggleTheme')

// 注入された値は通常のrefと同様に使用可能
watchEffect(() => {
  console.log('現在のテーマ:', theme.value)
})
</script>
```

### 動的コンポーネント
```vue
<template>
  <!-- 動的にコンポーネントを切り替える -->
  <component 
    :is="currentComponent" 
    :prop1="data1"
    @event="handleEvent"
  />
  
  <!-- KeepAliveでコンポーネントの状態を保持 -->
  <keep-alive>
    <!-- includeで特定のコンポーネントのみ保持 -->
    <component 
      :is="currentComponent" 
      v-if="currentComponent"
    />
  </keep-alive>
  
  <!-- Teleportで要素を別の場所に移動 -->
  <teleport to="#modal-container">
    <div v-if="showModal" class="modal">
      モーダルコンテンツ
    </div>
  </teleport>
</template>

<script setup>
import { ref, shallowRef, defineAsyncComponent } from 'vue'
import ComponentA from './ComponentA.vue'
import ComponentB from './ComponentB.vue'

// shallowRefでコンポーネントを管理（深いリアクティブを避ける）
const currentComponent = shallowRef(ComponentA)

// 非同期コンポーネントの定義
const AsyncComponent = defineAsyncComponent({
  // インポート関数
  loader: () => import('./AsyncComponent.vue'),
  // 読み込み中に表示するコンポーネント
  loadingComponent: LoadingComponent,
  // 読み込み遅延時間（ms）
  delay: 200,
  // エラー時に表示するコンポーネント
  errorComponent: ErrorComponent,
  // タイムアウト時間（ms）
  timeout: 3000
})

// コンポーネントの切り替え
const switchComponent = (component) => {
  currentComponent.value = component
}
</script>
```

### Mixins とコンポーザブル関数
```javascript
// mixins（Options API、非推奨）
export const counterMixin = {
  data() {
    return {
      count: 0
    }
  },
  methods: {
    increment() {
      this.count++
    }
  }
}

// コンポーザブル関数（推奨）
export function useCounter(initialValue = 0) {
  // ローカルなリアクティブステート
  const count = ref(initialValue)
  
  // 状態を変更する関数
  const increment = () => {
    count.value++
  }
  
  const decrement = () => {
    count.value--
  }
  
  // 複雑なロジック
  const doubleCount = computed(() => count.value * 2)
  
  // 副作用の管理
  watchEffect(() => {
    console.log(`カウント: ${count.value}`)
  })
  
  // 必要なものを返す
  return {
    count,
    increment,
    decrement,
    doubleCount
  }
}

// 使用例
<script setup>
import { useCounter } from '@/composables/useCounter'

// 複数のカウンターを独立して使用可能
const { count: count1, increment: increment1 } = useCounter(10)
const { count: count2, increment: increment2 } = useCounter(100)

// もちろん単一のインスタンスも可能
const counter = useCounter()
</script>
```

## テスト - 一行ずつ解説

### Vitest による単体テスト
```javascript
// sum.js - テスト対象の関数
export function sum(a, b) {
  return a + b
}

// sum.test.js
// テスト関連の関数をインポート
import { describe, it, expect, beforeEach, afterEach } from 'vitest'
// テスト対象の関数をインポート
import { sum } from './sum.js'

// テストスイート（関連するテストをグループ化）
describe('sum function', () => {
  // 個別のテストケース
  it('正数の足し算', () => {
    // 期待値のアサーション
    expect(sum(1, 2)).toBe(3)
  })
  
  it('負数の足し算', () => {
    expect(sum(-1, -2)).toBe(-3)
  })
  
  it('ゼロとの足し算', () => {
    expect(sum(5, 0)).toBe(5)
  })
})
```

### Vue コンポーネントのテスト
```javascript
// Button.vue - テスト対象のコンポーネント
<template>
  <button @click="handleClick" :disabled="disabled">
    {{ text }}
  </button>
</template>

<script setup>
const props = defineProps({
  text: String,
  disabled: Boolean
})

const emit = defineEmits(['click'])

const handleClick = () => {
  emit('click')
}
</script>

// Button.test.js
import { describe, it, expect } from 'vitest'
// Vue Test Utilsをインポート
import { mount } from '@vue/test-utils'
import Button from './Button.vue'

describe('Button.vue', () => {
  it('テキストプロップが正しく表示される', () => {
    // コンポーネントをマウント
    const wrapper = mount(Button, {
      props: {
        text: 'Click me'
      }
    })
    // DOMを検証
    expect(wrapper.text()).toBe('Click me')
  })
  
  it('disabledプロップが機能する', () => {
    const wrapper = mount(Button, {
      props: {
        disabled: true
      }
    })
    // disabled属性が設定されていることを確認
    expect(wrapper.find('button').element.disabled).toBe(true)
  })
  
  it('クリックイベントを発火する', async () => {
    const wrapper = mount(Button)
    // ボタンをクリック
    await wrapper.find('button').trigger('click')
    // emitイベントを検証
    expect(wrapper.emitted()).toHaveProperty('click')
  })
})
```

### E2Eテスト（Cypress例）
```javascript
// cypress/integration/login.spec.js
describe('ログイン機能', () => {
  // 各テスト前に実行
  beforeEach(() => {
    // ログインページにアクセス
    cy.visit('/login')
  })
  
  it('正しい認証情報でログインできる', () => {
    // 入力フィールドに値を入力
    cy.get('#email').type('user@example.com')
    cy.get('#password').type('password123')
    
    // ログインボタンをクリック
    cy.get('button[type=submit]').click()
    
    // ダッシュボードにリダイレクトされることを確認
    cy.url().should('include', '/dashboard')
    
    // 成功メッセージが表示されることを確認
    cy.get('.success-message').should('be.visible')
  })
  
  it('不正な認証情報でエラーが表示される', () => {
    cy.get('#email').type('wrong@example.com')
    cy.get('#password').type('wrongpassword')
    cy.get('button[type=submit]').click()
    
    // エラーメッセージが表示されることを確認
    cy.get('.error-message').should('contain', '認証に失敗しました')
  })
})
```

## ビルドとデプロイ

### Vite設定の最適化
```javascript
// vite.config.js
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
import path from 'path'

export default defineConfig({
  // Vueプラグインを使用
  plugins: [vue()],
  
  // エイリアスの設定
  resolve: {
    alias: {
      // '@' を 'src' ディレクトリにマップ
      '@': path.resolve(__dirname, './src'),
      // 'components' エイリアスを追加
      'components': path.resolve(__dirname, './src/components')
    }
  },
  
  // 開発サーバーの設定
  server: {
    // ポート番号
    port: 3000,
    // 自動でブラウザを開く
    open: true,
    // プロキシ設定（API呼び出し用）
    proxy: {
      '/api': {
        target: 'http://localhost:8080',
        changeOrigin: true,
        rewrite: (path) => path.replace(/^\/api/, '')
      }
    }
  },
  
  // ビルド設定
  build: {
    // 出力ディレクトリ
    outDir: 'dist',
    // ソースマップを生成
    sourcemap: true,
    // チャンク分割の設定
    rollupOptions: {
      output: {
        manualChunks(id) {
          // node_modules内のVueを別チャンクに
          if (id.includes('node_modules/vue')) {
            return 'vue'
          }
          // その他のnode_modulesをvendorチャンクに
          if (id.includes('node_modules')) {
            return 'vendor'
          }
        }
      }
    }
  },
  
  // 環境変数の設定
  define: {
    // グローバル定数を定義
    __APP_VERSION__: JSON.stringify(process.env.npm_package_version)
  }
})
```

### 環境変数の管理
```javascript
// .env.development
VITE_API_URL=http://localhost:8080/api
VITE_ENABLE_DEVTOOLS=true

// .env.production
VITE_API_URL=https://api.example.com
VITE_ENABLE_DEVTOOLS=false

// 使用例
<script setup>
// import.meta.env経由でアクセス
const apiUrl = import.meta.env.VITE_API_URL
const isDev = import.meta.env.DEV

// カスタムコンフィグ
const config = {
  apiUrl,
  timeout: 5000,
  headers: {
    'X-App-Version': import.meta.env.VITE_APP_VERSION || '1.0.0'
  }
}
</script>
```

## TypeScript対応

### TypeScript基本設定
```json
// tsconfig.json
{
  "compilerOptions": {
    // ECMAScript のターゲットバージョン
    "target": "ESNext",
    // 使用するJavaScriptライブラリ
    "lib": ["DOM", "ESNext"],
    // モジュールシステム
    "module": "ESNext",
    // モジュール解決方法
    "moduleResolution": "node",
    // 厳格な型チェック
    "strict": true,
    // JSXの変換方法（Vue用）
    "jsx": "preserve",
    // パスマッピング
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"]
    },
    // 型情報ファイル
    "types": ["vite/client"]
  },
  // 含めるファイル
  "include": [
    "src/**/*.ts",
    "src/**/*.d.ts",
    "src/**/*.tsx",
    "src/**/*.vue"
  ]
}
```

### TypeScript Vueコンポーネント
```vue
<template>
  <div>
    <h1>{{ user.name }}</h1>
    <button @click="updateUser">ユーザー更新</button>
  </div>
</template>

<script setup lang="ts">
// 型定義をインポート
import type { Ref } from 'vue'
import { ref, computed } from 'vue'

// インターフェースの定義
interface User {
  id: number
  name: string
  email: string
  role: 'admin' | 'user' | 'guest'
}

// レスポンス型の定義
interface ApiResponse<T> {
  data: T
  status: number
  message: string
}

// 型付きプロップス定義
const props = defineProps<{
  userId: number
  defaultUser?: User
}>()

// 型付きエミット定義
const emit = defineEmits<{
  (e: 'user-updated', user: User): void
  (e: 'error', error: Error): void
}>()

// 型付きリアクティブ変数
const user: Ref<User | null> = ref(null)
const isLoading = ref<boolean>(false)

// 算出プロパティに型注釈
const isAdmin = computed((): boolean => {
  return user.value?.role === 'admin' ?? false
})

// 非同期関数に型注釈
const fetchUser = async (id: number): Promise<void> => {
  isLoading.value = true
  try {
    // ジェネリクスを使用した型安全なAPI呼び出し
    const response = await fetch(`/api/users/${id}`)
    const data: ApiResponse<User> = await response.json()
    
    if (data.status === 200) {
      user.value = data.data
    } else {
      throw new Error(data.message)
    }
  } catch (error) {
    // 型ガードを使用したエラーハンドリング
    if (error instanceof Error) {
      emit('error', error)
    }
  } finally {
    isLoading.value = false
  }
}

// 関数の型注釈
const updateUser = (): void => {
  if (user.value) {
    emit('user-updated', user.value)
  }
}

// ライフサイクルフックでの型安全な処理
onMounted(() => {
  fetchUser(props.userId)
})
</script>
```

## 高度なテクニック

### カスタムフック (Composables)
```typescript
// composables/useApi.ts
import { ref, type Ref } from 'vue'

interface UseApiOptions {
  immediate?: boolean
  onSuccess?: (data: any) => void
  onError?: (error: Error) => void
}

// 汎用的なAPI呼び出しフック
export function useApi<T>(
  url: string, 
  options: UseApiOptions = {}
) {
  const data: Ref<T | null> = ref(null)
  const loading = ref(false)
  const error: Ref<Error | null> = ref(null)
  
  const execute = async (config: RequestInit = {}) => {
    loading.value = true
    error.value = null
    
    try {
      const response = await fetch(url, {
        headers: {
          'Content-Type': 'application/json',
          ...config.headers
        },
        ...config
      })
      
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`)
      }
      
      const result = await response.json()
      data.value = result
      options.onSuccess?.(result)
    } catch (err) {
      error.value = err as Error
      options.onError?.(err as Error)
    } finally {
      loading.value = false
    }
  }
  
  // 即時実行オプション
  if (options.immediate ?? true) {
    execute()
  }
  
  return {
    data,
    loading,
    error,
    execute,
    refresh: () => execute()
  }
}

// 使用例
<script setup lang="ts">
const { data: users, loading, error, refresh } = useApi<User[]>('/api/users', {
  onSuccess: (data) => console.log('ユーザー読み込み成功', data),
  onError: (err) => console.error('エラー', err)
})
</script>
```

### パフォーマンス監視
```javascript
// composables/usePerformance.ts
import { onMounted, onUnmounted } from 'vue'

export function usePerformance(componentName: string) {
  let startTime: number
  
  // Performance APIを使用した計測
  onMounted(() => {
    startTime = performance.now()
    
    // 初期描画時間を記録
    if (performance.getEntriesByType) {
      const paintEntries = performance.getEntriesByType('paint')
      console.log(`${componentName} Paint Timing:`, paintEntries)
    }
  })
  
  onUnmounted(() => {
    const duration = performance.now() - startTime
    console.log(`${componentName} was active for ${duration}ms`)
    
    // カスタムメトリクスを送信
    if (window.analytics) {
      window.analytics.track('component_lifetime', {
        name: componentName,
        duration
      })
    }
  })
  
  // メモリ使用量の監視
  const checkMemory = () => {
    if (performance.memory) {
      console.log(`Memory usage:`, {
        used: (performance.memory.usedJSHeapSize / 1048576).toFixed(2) + 'MB',
        total: (performance.memory.totalJSHeapSize / 1048576).toFixed(2) + 'MB'
      })
    }
  }
  
  return {
    checkMemory
  }
}
```

### 状態管理の高度パターン
```typescript
// stores/useAuthStore.ts
import { defineStore } from 'pinia'
import { computed, ref } from 'vue'

export const useAuthStore = defineStore('auth', () => {
  // 状態
  const user = ref<User | null>(null)
  const token = ref<string | null>(null)
  const refreshToken = ref<string | null>(null)
  
  // ゲッター
  const isAuthenticated = computed(() => !!token.value)
  const userRole = computed(() => user.value?.role || 'guest')
  
  // アクション
  const login = async (credentials: LoginCredentials) => {
    try {
      const response = await api.post('/auth/login', credentials)
      const { data } = response
      
      user.value = data.user
      token.value = data.token
      refreshToken.value = data.refreshToken
      
      // トークンをローカルストレージに保存
      localStorage.setItem('auth_token', data.token)
      localStorage.setItem('refresh_token', data.refreshToken)
      
      // Axios のデフォルトヘッダーを設定
      api.defaults.headers.common['Authorization'] = `Bearer ${data.token}`
      
      return true
    } catch (error) {
      console.error('Login failed:', error)
      return false
    }
  }
  
  const logout = async () => {
    try {
      await api.post('/auth/logout')
    } finally {
      user.value = null
      token.value = null
      refreshToken.value = null
      
      localStorage.removeItem('auth_token')
      localStorage.removeItem('refresh_token')
      delete api.defaults.headers.common['Authorization']
    }
  }
  
  // トークンの自動更新
  const refreshAuthToken = async () => {
    if (!refreshToken.value) return false
    
    try {
      const response = await api.post('/auth/refresh', {
        refreshToken: refreshToken.value
      })
      
      token.value = response.data.token
      localStorage.setItem('auth_token', response.data.token)
      api.defaults.headers.common['Authorization'] = `Bearer ${response.data.token}`
      
      return true
    } catch (error) {
      logout()
      return false
    }
  }
  
  // 初期化時にトークンを復元
  const initialize = async () => {
    const savedToken = localStorage.getItem('auth_token')
    const savedRefreshToken = localStorage.getItem('refresh_token')
    
    if (savedToken && savedRefreshToken) {
      token.value = savedToken
      refreshToken.value = savedRefreshToken
      api.defaults.headers.common['Authorization'] = `Bearer ${savedToken}`
      
      // ユーザー情報を取得
      try {
        const response = await api.get('/auth/me')
        user.value = response.data
      } catch (error) {
        // トークンが無効な場合はログアウト
        logout()
      }
    }
  }
  
  return {
    user,
    token,
    isAuthenticated,
    userRole,
    login,
    logout,
    refreshAuthToken,
    initialize
  }
})
```
